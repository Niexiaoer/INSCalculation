function [Vel_whole,Att_whole,VelError_whole,AttError_whole]=TraceState(IMUdata,dt)
    addpath('Quaternions');
    %%%%%%%%%%%%%%固定变量定义%%%%%%%%%%%%%%
    dGyro = [0;0;0];                                                       %陀螺仪固定零漂
    bAcc = [0;0;0];                                                        %加速表固定零漂
    
    Vel_whole = zeros(size(IMUdata,1),3);
    Att_whole = zeros(size(IMUdata,1),3); 
    VelError_whole = zeros(size(IMUdata,1),3);
    AttError_whole = zeros(size(IMUdata,1),3);
    
    Q_wg  = (0.005*pi/180)^2;                      						   %陀螺计白噪声
    Q_wa  = (100e-6*9.7935)^2;                                             %加速计白噪声
    Q     = diag([Q_wg Q_wg Q_wg, Q_wa Q_wa Q_wa]);                        %系统噪声协方差
    
    R = diag([1e-16,1e-16,1e-16]);                                            %观测方程噪声方差R
    
    Re 		= 6378245;   %地球长半径
    e 		= 1/298.257;  %地球扁率
    wie 	= 7.292e-5;  %地球自转角速度
    g = 9.793563;                                                           %地球重力加速度
    %%%%%%%%%%%%%%固定变量定义%%%%%%%%%%%%%%
    
%     %计算初始姿态角
%     Gyro_0 = (mean(IMUdata(1:1000,4:6)))'
%     Accb_0 = (mean(IMUdata(1:1000,1:3)))'
%     V_0 = cross_mine(Accb_0,Gyro_0)
%     Gyro_l = wiel
%     Accb_l = [0;0;-1]
%     V_l = cross_mine(Accb_l,Gyro_l)
%     Rbl_0 = inv([Accb_l';Gyro_l';V_l'])*[Accb_0';Gyro_0';V_0'];
% %    Attitude_0_test = (rotMat2euler(Rbl_0_test))'  
    
    %%%%%%%%%%%%%%系统状态向量初始化%%%%%%%%%%%%%%
    Velocity_0 = [0;0;0];
    VelocityChaRat_0 = [0;0;0];
    Attitude_0 = [-0.012574316;-0.000579696;0.145734];  %roll pitch yaw
    AttitudeChaRat_0 = [0;0;0;0]; 
    Position_GPS = [30.5273*pi/180;114.3551*pi/180;32.43];
    ErrorState = [0;0;0;0;0;0;0;0;0;0;0;0]; %error of Ve Vn Vu Pitch roll azimuth GyroErrors AccbErrors
    ErrorConv = diag([0.0001^2 0.0001^2 0.0001^2,(pi/6480)^2 (pi/6480)^2 (pi/180)^2,(0.05*pi/180)^2 (0.05*pi/180)^2 (0.05*pi/180)^2,0.02^2 0.02^2 0.02^2]);
    Rbl_0 = euler2rotMat(-Attitude_0(1),-Attitude_0(2),-Attitude_0(3));
    QA_0 = euler2quatern(-Attitude_0(1),-Attitude_0(2),-Attitude_0(3));
    QA_0 = normalize(QA_0); 
    Accb_0 = [0;0;0];
    %%%%%%%%%%%%%%系统状态向量初始化%%%%%%%%%%%%%%
    
    Rm = Re*(1-2*e+3*e*sin(Position_GPS(1))^2)+Position_GPS(3);
    Rn = Re*(1-e*sin(Position_GPS(1))^2)+Position_GPS(3);
    wiel = [0;wie*cos(Position_GPS(1));wie*sin(Position_GPS(1))];      %Wie在L系的表示
  
    for i=1:size(IMUdata,1)
        %IMU输入变量
        Accb_1 = IMUdata(i,1:3)';
        Gyro_1 = IMUdata(i,4:6)';
        
        %%%%%%%%%%%%%%%%%%%%%%%惯导解算%%%%%%%%%%%%%%%%%%%%%%%%
        QA_1 = QA_0+AttitudeChaRat_0;                                         
        QA_1 = normalize(QA_1);                   %该时刻的姿态四元数
        Rbl_1 = quatern2rotMat(QA_1);            %该时刻的姿态矩阵
        Attitude_1 = (rotMat2euler(Rbl_1))';      %更新该时刻的姿态角度
        
        Velocity_1 = Velocity_0+VelocityChaRat_0*dt;    %该时刻的速度  

        %%%%%%%%%%%%%%%%%%%%%%%惯导解算%%%%%%%%%%%%%%%%%%%%%%%%
        
        %%%%%%%%%%%%%%%%%%%%%%%科尔曼滤波%%%%%%%%%%%%%%%%%%%%%%%%    
        %连续系统状态转换阵 F 的时间更新
        F = zeros(12,12);  
        F(1:3,1:3) = [-Velocity_0(3)/Rn+Velocity_0(2)*tan(Position_GPS(1))/Rn,2*wie*sin(Position_GPS(1))+Velocity_0(1)*tan(Position_GPS(1))/Rn,-2*wie*cos(Position_GPS(1))-Velocity_0(1)/Rn;
                      -2*wie*sin(Position_GPS(1))-2*Velocity_0(1)*tan(Position_GPS(1))/Rn,-Velocity_0(3)/Rm,-Velocity_0(2)/Rm;
                      2*wie*cos(Position_GPS(1))+2*Velocity_0(1)/Rn,2*Velocity_0(2)/Rm,0];
        F(1:3,4:6) = [0,Accb_0(3),-Accb_0(2);
                      -Accb_0(3),0,Accb_0(1);
                      Accb_0(2),-Accb_0(1),0];
        F(1:3,10:12) = Rbl_0;
        F(4:6,1:3) = [0,1/Rm,0;
                      -1/Rn,0,0;
                      -tan(Position_GPS(1))/Rn,0,0];
        F(4:6,4:6) = [0,wie*sin(Position_GPS(1))+Velocity_0(1)*tan(Position_GPS(1))/Rn,-wie*cos(Position_GPS(1))-Velocity_0(1)/Rn;
                      -wie*sin(Position_GPS(1))-Velocity_0(1)*tan(Position_GPS(1))/Rn,0,-Velocity_0(2)/Rm;
                      wie*cos(Position_GPS(1))+Velocity_0(1)/Rn,Velocity_0(2)/Rm,0];
        F(4:6,7:9) = Rbl_0;
        F(7:9,7:9) = [-1/300 0 0;0 -1/300 0;0 0 -1/300];
        F(10:12,10:12) = [-1/1000 0 0;0 -1/1000 0;0 0 -1/1000];
    
        %连续系统量测阵更新
        H 	 = zeros(3,12);
        H(1,1) = 1;
        H(2,2) = 1;
        H(3,3) = 1;
        
        G = zeros(12,6);
        G(1:3,4:6) = Rbl_0;
        G(4:6,1:3) = Rbl_0;
        G(7:9,1:3) = eye(3,3);
        G(10:12,4:6) = eye(3,3);
    
        %连续系统离散化
        Fai = eye(12,12)+F*dt;
        Gk = (eye(12,12)+dt*F/2)*G*dt;
    
        %观测值更新
        Z = Velocity_1;
        %卡尔曼滤波
        ErrorState_pri = Fai*ErrorState;                                       %卡尔曼滤波第一项方程
        ErrorConv_pri = Fai*ErrorConv*Fai'+ Gk*Q*Gk';                          %卡尔曼滤波第二项方程
        KalGain = ErrorConv_pri*H'*inv(H*ErrorConv_pri*H'+ R);                    %卡尔曼滤波第三项方程
        ErrorState = ErrorState_pri+KalGain*(Z-H*ErrorState_pri);              %卡尔曼滤波第四项方程
        ErrorConv = (eye(12,12)-KalGain*H)*ErrorConv_pri;                      %卡尔曼滤波第五项方程
        %%%%%%%%%%%%%%%%%%%%%%%科尔曼滤波%%%%%%%%%%%%%%%%%%%%%%%%  
              
         %更正该时刻的速度和姿态
         Velocity_1 = Velocity_1-ErrorState(1:3); %更正后的改时刻的速度
         Attitude_1 = Attitude_1-ErrorState(4:6);%更正后的该时刻的姿态角度;      
         Rbl_1 = euler2rotMat(Attitude_1(1),Attitude_1(2),Attitude_1(3)); %更正后的该时刻的旋转矩阵;
         QA_1 = rotMat2quatern(Rbl_1);                                    %更正后的该时刻的四元数;
       
        %计算该时刻的速度变化率和姿态变化率
        well = [-Velocity_1(2)/Rm;Velocity_1(1)/Rn;Velocity_1(1)*tan(Position_GPS(1))/Rn];%Wel在L系的重新表示
        VelocityChaRat_1 = Rbl_1*(Accb_1-bAcc)*g-cross_mine(2*wiel+well,Velocity_1)+[0;0;g];%该时刻的速度变化率
        xitaib = Gyro_1*dt-dGyro*dt;  
        xitail = Rbl_1'*(wiel+well)*dt;
        xitalb = xitaib-xitail;
        omigalb = [0 xitalb(3) -xitalb(2) xitalb(1);
                   -xitalb(3) 0 xitalb(1) xitalb(2);
                   xitalb(2) -xitalb(1) 0 xitalb(3);
                   -xitalb(1) -xitalb(2) -xitalb(3) 0];
        AttitudeChaRat_1 = 0.5*omigalb*QA_1;                                 %更新姿态四元树变化率
        
        %更新变量
        Velocity_0 = Velocity_1;
        Attitude_0 = Attitude_1;
        Rbl_0 = Rbl_1;
        QA_0 = QA_1;
        VelocityChaRat_0 = VelocityChaRat_1;
        AttitudeChaRat_0 = AttitudeChaRat_1;
        Accb_0 = Accb_1;
        
        Vel_whole(i,:) = Velocity_0';
        Att_whole(i,:) = Attitude_0';
        VelError_whole(i,:) = ErrorState(1:3)';
        AttError_whole(i,:) = ErrorState(4:6)';

    end   
     %%  叉乘  %%
function out = cross_mine(V1,V2)
R1 = [0 -V1(3) V1(2);
      V1(3) 0 -V1(1);
      -V1(2) V1(1) 0];
out   = R1*V2;
end

     %% 正交化四元数 %%
function Qout = normalize(Q)
delta = 1-(Q(1)^2+Q(2)^2+Q(3)^2+Q(4)^2);
Qout   = Q*(1+delta/2);
end    
end